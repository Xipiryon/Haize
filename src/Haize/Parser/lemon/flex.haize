%option reentrant
%option noyywrap nodefault nounistd never-interactive
%option warn nodebug

%{
#pragma warning(disable: 4003) // not enough actual parameters for macro 'yywrap'
#pragma warning(disable: 4005) // macro redefinition (like INT8_MIN and so on...)

namespace utils
{
	int hex2int(char* str);
	int oct2int(char* str);
	int bin2int(char* str);
}

#	if 0
#define HZ_CHAR g_charCount += yyleng
#	else
#define HZ_CHAR
#	endif
#define HZ_TOK(token) /*if(!g_multiLineComment)*/ return token

#include <Muon/String.hpp>
#include "Haize/Parser/Token.hpp"

using namespace hz::parser;
%}

_Letters	[a-zA-Z_]

NewLine		[\r\n]
Separator 	[;]

LineComment			\/\/.*{NewLine}
%x MultiLineComment

HexNumber	0[xX][0-9a-fA-F]+
OctNumber	0[0-7]+
BinNumber	0[bB][0-1]+

_IntRange	[0-9]
Integer		[1-9]{_IntRange}*|0
Float		{_IntRange}\.{_IntRange}*f?
Identifer	{_Letters}({_Letters}|{_IntRange})*
%x StringBlock

%%

[ \t]		{ HZ_CHAR; }
{NewLine}	{ /*++g_lineCount; g_charCount = 0;*/ }
{Separator}	{ HZ_CHAR; HZ_TOK(S_SEPARATOR); }


<INITIAL>{
	\/\*			{ BEGIN(MultiLineComment); }
}
<MultiLineComment>{
	\*\/			{ BEGIN(INITIAL); }
	[^*\r\n]		{ }
	"*"				{ /*++g_charCount;*/ }
	{NewLine}		{ /*++g_lineCount; g_charCount = 0;*/ }
}
{LineComment}	{ /*++g_lineCount; g_charCount = 0;*/ }


"true"		{ /*HZ_CHAR; lexData->integer = 1; HZ_TOK(V_TRUE);*/ }
"false"		{ /*HZ_CHAR; lexData->integer = 0; HZ_TOK(V_FALSE);*/ }
"nil"		{ /*HZ_CHAR; lexData->integer = 0; HZ_TOK(V_NIL);*/ }

"if"		{ HZ_CHAR; HZ_TOK(K_IF); }
"else"		{ HZ_CHAR; HZ_TOK(K_ELSE); }
"for"		{ HZ_CHAR; HZ_TOK(K_FOR); }
"while"		{ HZ_CHAR; HZ_TOK(K_WHILE); }
"switch"	{ HZ_CHAR; HZ_TOK(K_SWITCH); }
"break"		{ HZ_CHAR; HZ_TOK(K_BREAK); }
"continue"	{ HZ_CHAR; HZ_TOK(K_CONTINUE); }
"return"	{ HZ_CHAR; HZ_TOK(K_RETURN); }

"global"	{ HZ_CHAR; HZ_TOK(K_GLOBAL); }

"namespace"	{ HZ_CHAR; HZ_TOK(K_NAMESPACE); }
"class"		{ HZ_CHAR; HZ_TOK(K_CLASS); }
"in"		{ HZ_CHAR; HZ_TOK(K_IN); }
"out"		{ HZ_CHAR; HZ_TOK(K_OUT); }

{HexNumber}	{
	//lexData->integer = utils::hex2int(yytext);
	HZ_CHAR;
	HZ_TOK(V_NUMBER);
}

{OctNumber}	{
	//lexData->integer = utils::oct2int(yytext);
	HZ_CHAR;
	HZ_TOK(V_NUMBER);
}

{BinNumber}	{
	//lexData->integer = utils::bin2int(yytext);
	HZ_CHAR;
	HZ_TOK(V_NUMBER);
}

{Integer}	{ /*HZ_CHAR; lexData->integer = atoi(yytext); HZ_TOK(V_NUMBER);*/ }
{Float}		{ /*HZ_CHAR; lexData->floating = (float)atof(yytext); HZ_TOK(V_FLOATING);*/ }
{Identifer}	{ /*HZ_CHAR; lexData->string = MUON_CNEW(muon::String, yytext); HZ_TOK(V_IDENT);*/ }

<INITIAL>{
	\"			{ BEGIN(StringBlock); }
}
<StringBlock>{
	\"				{	BEGIN(INITIAL);
						//yylval.string = MUON_CNEW(muon::String, g_strBuffer);
						//g_strBuffer.clear();
						HZ_TOK(V_STRING);
					}
	[^"\n]+			{ /*g_strBuffer += yytext;*/}
	{NewLine}		{ /*g_strBuffer += yytext; ++g_lineCount; g_charCount = 0;*/ }
}

"."		{ HZ_CHAR; HZ_TOK(S_ACCESSOR); }
","		{ HZ_CHAR; HZ_TOK(S_COMMA); }
"("		{ HZ_CHAR; HZ_TOK(S_LPARENT); }
")"		{ HZ_CHAR; HZ_TOK(S_RPARENT); }
"{"		{ HZ_CHAR; HZ_TOK(S_LBRACE); }
"}"		{ HZ_CHAR; HZ_TOK(S_RBRACE); }
"["		{ HZ_CHAR; HZ_TOK(S_LBRACKET); }
"]"		{ HZ_CHAR; HZ_TOK(S_RBRACKET); }

"="		{ HZ_CHAR; HZ_TOK(MATH_ASN); }
"+"		{ HZ_CHAR; HZ_TOK(MATH_ADD); }
"-"		{ HZ_CHAR; HZ_TOK(MATH_SUB); }
"*"		{ HZ_CHAR; HZ_TOK(MATH_MUL); }
"/"		{ HZ_CHAR; HZ_TOK(MATH_DIV); }
"%"		{ HZ_CHAR; HZ_TOK(MATH_MOD); }

"+="	{ HZ_CHAR; HZ_TOK(MATH_ASN_ADD); }
"-="	{ HZ_CHAR; HZ_TOK(MATH_ASN_SUB); }
"*="	{ HZ_CHAR; HZ_TOK(MATH_ASN_MUL); }
"/="	{ HZ_CHAR; HZ_TOK(MATH_ASN_DIV); }
"%="	{ HZ_CHAR; HZ_TOK(MATH_ASN_MOD); }

"<"		{ HZ_CHAR; HZ_TOK(LOGIC_LT); }
">"		{ HZ_CHAR; HZ_TOK(LOGIC_GT); }
"<="	{ HZ_CHAR; HZ_TOK(LOGIC_LET); }
">="	{ HZ_CHAR; HZ_TOK(LOGIC_GET); }
"=="	{ HZ_CHAR; HZ_TOK(LOGIC_EQ); }
"!="	{ HZ_CHAR; HZ_TOK(LOGIC_NEQ); }
"&&"	{ HZ_CHAR; HZ_TOK(LOGIC_AND); }
"||"	{ HZ_CHAR; HZ_TOK(LOGIC_OR); }
"!"		{ HZ_CHAR; HZ_TOK(LOGIC_NOT); }

">>"	{ HZ_CHAR; HZ_TOK(BITWISE_RSH); }
"<<"	{ HZ_CHAR; HZ_TOK(BITWISE_LSH); }
"&"		{ HZ_CHAR; HZ_TOK(BITWISE_AND); }
"|"		{ HZ_CHAR; HZ_TOK(BITWISE_OR); }
"~"		{ HZ_CHAR; HZ_TOK(BITWISE_NOT); }
"^"		{ HZ_CHAR; HZ_TOK(BITWISE_XOR); }
"&="	{ HZ_CHAR; HZ_TOK(MATH_ASN_BITWISE_AND); }
"|="	{ HZ_CHAR; HZ_TOK(MATH_ASN_BITWISE_OR); }
"^="	{ HZ_CHAR; HZ_TOK(MATH_ASN_BITWISE_XOR); }
"~="	{ HZ_CHAR; HZ_TOK(MATH_ASN_BITWISE_NOT); }
">>="	{ HZ_CHAR; HZ_TOK(MATH_ASN_BITWISE_RSH); }
"<<="	{ HZ_CHAR; HZ_TOK(MATH_ASN_BITWISE_LSH); }

.		{ HZ_CHAR; }
<<EOF>>	{ yyterminate(); }
