#include <cstdlib>
#include <cstring>
#include <fstream>
#include <string>
#include <iostream>

#include <Muon/Core/Define.hpp>
#include <Muon/System/Log.hpp>
#include "Haize/Engine.hpp"

namespace
{
	hz::Context* g_Context = NULL;
	bool g_Evaluate = false;
	bool g_LoadFile = false;
	bool g_LoadBytecode = false;
	bool g_ExportBytecode = false;
	m::String g_Expr;
	m::String g_Filename;
	char* g_Buffer;

	void displayUsage()
	{
		m::system::Log log("", m::LOG_INFO);
#define HAIZE_USAGE_LOG(Option, Text) log() << " " Option << " \t " Text << m::endl << m::endl
		HAIZE_USAGE_LOG("-e \"EXPR\"",
						"Evaluate the expression EXPR and return." << m::endl
						<< "\t EXPR will be encapsulated in a function 'int main()'," << m::endl
						<< "\t where the returned value is the register index holding " << m::endl
						<< "\t the result of any 'return' statement. ");
		HAIZE_USAGE_LOG("-f FILE", "Load and evaluate the content located in FILE.");
		HAIZE_USAGE_LOG("-b FILE", "Load and evaluate the bytecode content located in FILE.");
		HAIZE_USAGE_LOG("-o", "Export generated bytecode to 'FILE.hzc'." << m::endl
						<< "\t Works only with -f or -e option.");
#undef HAIZE_USAGE_LOG
	}
}

bool parseArguments(int, char**);
void executeProgram();

int main(int argc, char** argv)
{
	m::system::Log::registerDefaultLogImpl();
	m::system::Log log("", m::LOG_INFO);
	log() << " Haize v" << HAIZE_VERSION << ", a C++ Script Language " << m::endl;
	log() << " Copyright (C) 2015-2016 Louis Schnellbach" << m::endl
		<< m::endl;

	g_Context = hz::Engine::getInstance().createContext("__EXPR__");

	if (parseArguments(argc, argv))
	{
		executeProgram();
	}
	else
	{
		displayUsage();
	}

	m::system::Log::close();
	hz::Engine::getInstance().destroyContext("__EXPR__");
	g_Context = NULL;

#ifdef MUON_PLATFORM_WINDOWS
	::system("PAUSE");
#endif
	return 0;
}

bool parseArguments(int argc, char** argv)
{
	m::system::Log log("Main", m::LOG_INFO);
	bool validArgument = false;

	for (int i = 0; i < argc; ++i)
	{
		// EVAL EXPR
		if (!strcmp(argv[i], "-e"))
		{
			if (++i < argc)
			{
				g_Expr += argv[i];
			}
			else
			{
				log(m::LOG_ERROR) << "Missing EXPR after -e argument (use quotes)!" << m::endl;
			}
			g_Evaluate = true;
			validArgument = true;
		}
		// EXPORT BYTECODE
		else if (!strcmp(argv[i], "-o"))
		{
			g_ExportBytecode = true;
		}
		// LOAD FILE
		else if (!strcmp(argv[i], "-f"))
		{
			if (++i < argc)
			{
				g_Filename = argv[i];
				g_LoadFile = true;
				validArgument = true;
			}
			else
			{
				log(m::LOG_ERROR) << "Missing FILE after -f argument!" << m::endl;
			}
		}
		// BYTECODE LOAD FILE
		else if (!strcmp(argv[i], "-b"))
		{
			if (++i < argc)
			{
				g_Filename = argv[i];
				std::ifstream file(g_Filename.cStr());
				if (!file)
				{
					log(m::LOG_ERROR) << "Couldn't load: " << g_Filename << m::endl;
					return false;
				}
				if (!file.eof())
				{
					file.seekg(0, std::ios::end);
					m::u64 length = (m::u64)file.tellg();
					file.seekg(0, std::ios::beg);
					log(m::LOG_INFO) << "Reading " << length << " bytes ..." << m::endl;
					g_Buffer = (char*)malloc(sizeof(char) * (size_t)length);
					file.read(g_Buffer, length);
					log(m::LOG_INFO) << "... done !" << m::endl;
					validArgument = true;
					g_LoadBytecode = true;
				}
			}
			else
			{
				log(m::LOG_ERROR) << "Missing FILE after -b argument!" << m::endl;
			}
		}
	}

	return validArgument;
}

void executeProgram()
{
	m::system::Log log("Haize", m::LOG_INFO);

	if (g_Evaluate)
	{
		log() << "> Parsing \"" << g_Expr << "\"" << m::endl;
		if (g_Context->eval(g_Expr.cStr()) || true)
		{
			if (g_ExportBytecode)
			{
				m::String outputFilename = "eval.bytecode";
				log() << "ByteCode written into \"" << outputFilename << "\"" << m::endl;
				std::ofstream file(outputFilename.cStr(), std::ios::binary | std::ios::trunc);
				//file.write((const char*)vm.getInfo().IRCode, vm.getInfo().IRCodeSize);
				file.close();
			}
		}

		return;
	}
	// LOAD FILE
	else if (g_LoadFile)
	{
		m::String module = "RuntimeEval";
		log() << "> Parsing \"" << g_Filename << "\"" << m::endl;
		if (!g_Context->load(g_Filename.cStr()))
		{
			log(m::LOG_ERROR) << "Couldn't load " << g_Filename << "!" << m::endl;
			return;
		}

		if (!g_Context->compile())
		{
			log(m::LOG_ERROR) << "Couldn't compile " << g_Filename << "!" << m::endl;
			return;
		}

		if (!g_Context->execute())
		{
			log(m::LOG_ERROR) << "Couldn't execute " << g_Filename << "!" << m::endl;
			return;
		}

		if (g_ExportBytecode)
		{
			m::String outputFilename = g_Filename + "c";
			log() << "Writing ByteCode to \"" << outputFilename << "\"" << m::endl;
			std::ofstream file(outputFilename.cStr(), std::ios::binary | std::ios::trunc);
			file.write((const char*)g_Context->getByteCodePtr(), g_Context->getByteCodeSize());
			file.close();
		}
		return;
	}
	// BYTECODE LOAD FILE
	else if (g_LoadBytecode)
	{
		log() << "> Parsing \"" << g_Filename << "\"" << m::endl;
		// TODO
		free(g_Buffer);
		return;
	}
}
