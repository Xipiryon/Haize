#include <cstdlib>
#include <cstring>
#include <fstream>
#include <string>
#include <iostream>

#include <Muon/Core/Define.hpp>
#include <Muon/System/Log.hpp>

#include "Haize/Module.hpp"
#include "Haize/Context.hpp"

namespace
{
	hz::Module g_Module("Global");
	bool g_LoadFile = false;
	bool g_LoadBytecode = false;
	bool g_ExportBytecode = false;
	m::String g_Expr;
	m::String g_Filename;
	char* g_Buffer;

	void displayUsage()
	{
		m::system::Log log("", m::LOG_INFO);
#define HAIZE_USAGE_LOG(Option, Text) log() << " " Option << " \t " Text << m::endl << m::endl
		HAIZE_USAGE_LOG("-f FILE", "Load and evaluate the content located in FILE.");
		HAIZE_USAGE_LOG("-b FILE", "Load and evaluate the bytecode content located in FILE.");
		HAIZE_USAGE_LOG("-o", "Export generated bytecode to 'FILE.hzc'." << m::endl
						<< "\t Works only with -f option.");
#undef HAIZE_USAGE_LOG
	}
}

bool parseArguments(int, char**);
void executeProgram();

int main(int argc, char** argv)
{
	m::system::Log::registerDefaultLogImpl();
	m::system::Log log("", m::LOG_INFO);
	log() << " Haize v" << HAIZE_VERSION << ", a C++ Script Language " << m::endl;
	log() << " Copyright (C) 2015-2016 Louis Schnellbach" << m::endl
		<< m::endl;

	if (parseArguments(argc, argv))
	{
		executeProgram();
	}
	else
	{
		displayUsage();
	}

	m::system::Log::close();

#ifdef MUON_PLATFORM_WINDOWS
	::system("PAUSE");
#endif
	return 0;
}

bool parseArguments(int argc, char** argv)
{
	m::system::Log log("Main", m::LOG_INFO);
	bool validArgument = false;

	for (int i = 0; i < argc; ++i)
	{
		// EXPORT BYTECODE
		if (!strcmp(argv[i], "-o"))
		{
			g_ExportBytecode = true;
		}
		// LOAD FILE
		else if (!strcmp(argv[i], "-f"))
		{
			if (++i < argc)
			{
				g_Filename = argv[i];
				g_LoadFile = true;
				validArgument = true;
			}
			else
			{
				log(m::LOG_ERROR) << "Missing FILE after -f argument!" << m::endl;
			}
		}
		// BYTECODE LOAD FILE
		else if (!strcmp(argv[i], "-b"))
		{
			if (++i < argc)
			{
				g_Filename = argv[i];
				std::ifstream file(g_Filename.cStr());
				if (!file)
				{
					log(m::LOG_ERROR) << "Couldn't load: " << g_Filename << m::endl;
					return false;
				}
				if (!file.eof())
				{
					file.seekg(0, std::ios::end);
					m::u64 length = (m::u64)file.tellg();
					file.seekg(0, std::ios::beg);
					log(m::LOG_INFO) << "Reading " << length << " bytes ..." << m::endl;
					g_Buffer = (char*)malloc(sizeof(char) * (size_t)length);
					file.read(g_Buffer, length);
					log(m::LOG_INFO) << "... done !" << m::endl;
					validArgument = true;
					g_LoadBytecode = true;
					g_ExportBytecode = false;
				}
			}
			else
			{
				log(m::LOG_ERROR) << "Missing FILE after -b argument!" << m::endl;
			}
		}
	}

	if (g_LoadBytecode && g_LoadFile)
	{
		log(m::LOG_ERROR) << "You can specify both -b and -f!" << m::endl;
		validArgument = false;
	}

	return validArgument;
}

void executeProgram()
{
	m::system::Log log("Haize", m::LOG_INFO);

	// LOAD FILE
	if (g_LoadFile)
	{
		m::String module = "RuntimeEval";
		log() << "> Parsing \"" << g_Filename << "\"" << m::endl;
		if (!g_Module.load(g_Filename.cStr()))
		{
			log(m::LOG_ERROR) << "Couldn't load " << g_Filename << "!" << m::endl;
			return;
		}

		if (!g_Module.compile())
		{
			log(m::LOG_ERROR) << "Couldn't compile " << g_Filename << "!" << m::endl;
			return;
		}

		hz::Context ctx(g_Module);
		if (!ctx.execute())
		{
			log(m::LOG_ERROR) << "Couldn't execute " << g_Filename << "!" << m::endl;
			return;
		}

		if (g_ExportBytecode)
		{
			m::String outputFilename = g_Filename + "c";
			log() << "Writing ByteCode to \"" << outputFilename << "\"" << m::endl;
			std::ofstream file(outputFilename.cStr(), std::ios::binary | std::ios::trunc);
			file.write((const char*)g_Module.getByteCodePtr(), g_Module.getByteCodeSize());
			file.close();
		}
		return;
	}
	// BYTECODE LOAD FILE
	else if (g_LoadBytecode)
	{
		log() << "> Parsing \"" << g_Filename << "\"" << m::endl;
		// TODO
		free(g_Buffer);
		return;
	}
}
